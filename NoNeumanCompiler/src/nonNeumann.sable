Package br.ufs.dcomp.compilers.project.nonneumann;

Helpers
	hex_identifier = '0x';
	semicolon = ';';
	multi_line_comment_open = '{-';
	multi_line_comment_close = '-}';
	any_char = [0x0 .. 0xfffff];
	hex_alpha_numerical_digit = ['A'..'F'];
	digit = ['0'..'9'];
	char = (['a'..'z'] | ['A'..'Z']);
	space = ' ';
	rc = 13;
	nl = 10;
	tab = 9;
 
Tokens
	tk_comment_line = (semicolon([0..9] | 11 | 12 | [14..0xfffff])*);
	tk_comment_multi_line = (multi_line_comment_open(([0..44] | [46..0xfffff]) | ('-'+([0..44] | [46..124] | [126..0xfffff])))*'-'+'}');
	

	tk_reserved_entry = 'entry';
	tk_reserved_function = 'function';
	tk_reserved_const = 'const';
	tk_reserved_type_int = 'int';
	tk_reserved_type_bool = 'bool';
	tk_reserved_type_real = 'real';
	tk_reserved_bool_true = 'true';
	tk_reserved_bool_false = 'false';
	tk_reserved_bool_and = 'and';
	tk_reserved_bool_or = 'or';	
	tk_reserved_if = 'if';
	tk_reserved_then = 'then';
	tk_reserved_else = 'else';
	tk_reserved_lambda = 'lambda';
	
	tk_number_integer_dec = (digit+);
	tk_number_integer_hex = (hex_identifier(digit | hex_alpha_numerical_digit)+);
 	
 	tk_number_float = (digit+('.')digit+);
 	tk_number_float_cientific_notation = ((digit+)('E')('-')?(digit+));
 	
	tk_sign_plus = '+';
	tk_sign_minus = '-';
	tk_sign_mult = '*';
	tk_sign_div = '/';
	tk_sign_mod = '%';
	tk_sign_colon = ':';
	tk_sign_comma = ',';
	tk_sign_exclamation = '!';
	tk_sign_par_open = '(';
	tk_sign_par_close = ')';
	tk_sign_brace_open = '[';
	tk_sign_brace_close = ']';
	tk_sign_bool_equal = '=';
	tk_sign_bool_gt = '>';
	tk_sign_bool_lt = '<';
 
	tk_blank = (space | rc | nl | tab)+;
	
	tk_id = ((char | '_')+(digit | char)*);
	
Ignored Tokens
	tk_blank,
	tk_comment_line,
	tk_comment_multi_line;
	
Productions
	program = function_dec+;
	
	function_dec = tk_reserved_entry? tk_sign_par_open tk_reserved_function type tk_id parameters_function_aux tk_sign_colon exp_function_aux tk_sign_par_close;
	
	parameters_function_aux = tk_sign_par_open parameters* tk_sign_par_close;
	
	exp_function_aux = tk_sign_par_open exp tk_sign_par_close;
		
	signature = type tk_id tk_sign_par_open parameter_signature tk_sign_par_close;

	lambda = tk_reserved_lambda tk_sign_par_open id_list? tk_sign_par_close tk_sign_colon term tk_sign_brace_open lambda_exp_list? tk_sign_brace_close;	
	
	dec_cons = {dec_cons}tk_sign_par_open tk_reserved_const type tk_id exp tk_sign_par_close;

	parameters_signature_aux = tk_sign_comma parameters_signature;
	
	lambda_exp_list = exp lambda_exp_list_aux*;

	type = {tk_reserved_type_int}tk_reserved_type_int
		|{tk_reserved_type_bool}tk_reserved_type_bool
		|{tk_reserved_type_real}tk_reserved_type_real;	
		
	
	lambda_exp_list_aux = tk_sign_comma exp;
	
	boolean_value = {tk_reserved_bool_true}tk_reserved_bool_true
		|{tk_reserved_bool_false}tk_reserved_bool_false;	
	
	parameters = parameter parameters_aux*;
	
	parameters_aux = tk_sign_comma parameter;
	

	term = {literal} literal 
		|{function_call} function_call
		|{exp} tk_sign_par_open dec_cons* exp tk_sign_par_close;	
	
	parameter =  {dec}type tk_id
		|{signature}signature;
	
	parameter_signature = {type}type
		|{signature}signature;
		
	if_stmt = if_stmt_exp_aux tk_reserved_then term if_stmt_else_aux;
		
	parameters_signature = parameter_signature parameters_signature_aux*;	
	
	id_list = tk_id id_list_aux*;
	
	id_list_aux = tk_sign_comma tk_id;
	
	op = {factor}factor
		|{plus}op tk_sign_plus factor
  		|{minus}op tk_sign_minus factor;
			
	factor = {term} term
		|{mult} factor tk_sign_mult term
		|{neg} negation
		|{div} factor tk_sign_div term
		|{mod} factor tk_sign_mod term;
		
	negation = tk_sign_minus term;
	
	literal = {boolean_value}boolean_value
		|{numeral_float}numeral_float
		|{numeral_int}numeral_int;

	exp = {gt} exp tk_sign_bool_gt op
		|{lt}exp tk_sign_bool_lt op
		|{equal}exp tk_sign_bool_equal op
		|{neg_bool} tk_sign_exclamation op
		|{and}exp tk_reserved_bool_and op
		|{or}exp tk_reserved_bool_or op
		|{if_stmt} if_stmt
		|{lambda} lambda
		|{op}op;
		
	if_stmt_exp_aux = tk_reserved_if term;
	
	if_stmt_else_aux = tk_reserved_else term;
	
	numeral_float = {tk_number_float}tk_number_float
		|{tk_number_float_cientific_notation}tk_number_float_cientific_notation;
		
	numeral_int = {tk_number_integer_dec}tk_number_integer_dec
		|{tk_number_integer_hex}tk_number_integer_hex;
	
	function_call = {id}tk_id tk_sign_par_open exp_list? tk_sign_par_close;
	
	exp_list = {exp_list}exp exp_list_aux*;
		
	exp_list_aux = {exp_list_aux}tk_sign_comma exp;
		
	

		